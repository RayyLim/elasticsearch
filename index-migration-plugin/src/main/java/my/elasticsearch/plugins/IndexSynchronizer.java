/********************************************************************
 * File Name:    IndexSynchronizer.java
 *
 * Date Created: Sep 23, 2016
 *
 * ------------------------------------------------------------------
 * 
 * Copyright @ 2016 ajeydudhe@gmail.com
 *
 *******************************************************************/

package my.elasticsearch.plugins;

import org.elasticsearch.client.Client;
import org.elasticsearch.common.logging.ESLogger;
import org.elasticsearch.common.logging.slf4j.Slf4jESLoggerFactory;
import org.elasticsearch.common.lucene.uid.Versions;
import org.elasticsearch.index.VersionType;
import org.elasticsearch.index.engine.Engine.Create;
import org.elasticsearch.index.engine.Engine.Index;
import org.elasticsearch.index.engine.Engine.IndexingOperation;
import org.elasticsearch.index.indexing.IndexingOperationListener;
import org.elasticsearch.index.indexing.ShardIndexingService;
import org.elasticsearch.index.shard.IndexShard;

import static org.elasticsearch.index.mapper.SourceToParse.source;
  
public class IndexSynchronizer implements AutoCloseable
{
  /*
  public IndexSynchronizer(final IndicesService indicesService, 
                           final String sourceIndex,
                           final String targetIndex)*/
  
  public IndexSynchronizer(final ShardIndexingService sourceIndexingService, final IndexShard targetIndexShard) 
  {
    final String sourceIndex = sourceIndexingService.shardId().getIndex();
    final String targetIndex = targetIndexShard.shardId().getIndex();
    
    LOGGER.error("### Synchronizing documents from [{}] to [{}]", sourceIndex, targetIndex);
    
    this.sourceIndexingService = sourceIndexingService; //getIndexingService(sourceIndex);
    if(this.sourceIndexingService == null)
    {
      LOGGER.error("### Source indexing service not found [{}]", sourceIndex);
      return;
    }
    
    this.targetIndexShard = targetIndexShard;
    /*
    this.targetIndexingService = targetIndexingService; //getIndexingService(targetIndex);
    if(this.targetIndexingService == null)
    {
      LOGGER.error("### Target indexing service not found [{}]", targetIndex);
      return;
    }*/
    
    this.indexingOperationListener = getIndexingOperationListener();
    
    this.sourceIndexingService.addListener(this.indexingOperationListener);
  }

  private IndexingOperationListener getIndexingOperationListener()
  {
    return new IndexingOperationListener()
    {
      @Override
      public Create preCreate(final Create create)
      {
        logDocumentInfo("### preCreate", create);
        
        return super.preCreate(create);
      }
      
      @Override
      public void postCreate(final Create create)
      {
        logDocumentInfo("### postCreate", create);
        create.updateVersion(Versions.MATCH_ANY); // There is check inside the create call.
        
        final Create target =
        targetIndexShard.prepareCreate(source(create.source()).type(create.type()).id(create.id())
                                              .routing(create.routing()).parent(create.parent()).timestamp(create.timestamp()).ttl(create.ttl()), 
                                       create.version(), create.versionType(), create.origin(), create.canHaveDuplicates(), create.autoGeneratedId());
        
        targetIndexShard.create(target);
      }
      
      @Override
      public Index preIndex(final Index index)
      {
        logDocumentInfo("### preIndex", index);
        return super.preIndex(index);
      }
      
      @Override
      public void postIndex(final Index index)
      {
        logDocumentInfo("### postIndex", index);
        
        final Index target = targetIndexShard.prepareIndex(source(index.source()).type(index.type()).id(index.id())
                                                                  .routing(index.routing()).parent(index.parent()).timestamp(index.timestamp()).ttl(index.ttl()), 
                                                           index.version() + 100, // TODO: Ajey - We are adding 100 to check external version works 
                                                           VersionType.EXTERNAL, 
                                                           index.origin(), 
                                                           index.canHaveDuplicates());
            
        //final Index targetIndex = new Index(index.docMapper(), index.uid(), index.parsedDoc(), index.version() + 100, VersionType.EXTERNAL, index.origin(), index.startTime());
        
        targetIndexShard.index(target);
      }
      
      private void logDocumentInfo(final String context, final IndexingOperation operation)
      {
        LOGGER.error("### {}\n_type: {}\n_id: {}\n_version: {}\n_versionType: {}\nstartTime: {}\nOrigin: {}\nsource: \n{}",
                     context,
                     operation.type(), 
                     operation.id(),
                     operation.version(),
                     operation.versionType(),
                     operation.startTime(),
                     operation.origin(),
                     operation.parsedDoc().source().toUtf8());
      }
    };
  }

  /*
  private ShardIndexingService getIndexingService(final String indexName)
  {
    LOGGER.error("### Getting indexing service for [{}]", indexName);
    final IndexService indexService = this.indicesService.indexService(indexName);
    
    if(indexService == null)
       return null;
    
    LOGGER.error("### Shard ids: {}", indexService.shardIds());
    
    return indexService.shard(0).indexingService(); // Returning for shard 0.
  }*/
  
  @Override
  public void close()
  {
    if(this.indexingOperationListener != null)
    {
      this.sourceIndexingService.removeListener(this.indexingOperationListener);
      this.indexingOperationListener = null;
    }      
  }
  
  // Private
  //private final IndicesService indicesService;
  private ShardIndexingService sourceIndexingService;
  private IndexShard targetIndexShard;
  private IndexingOperationListener indexingOperationListener;
  private final static ESLogger LOGGER = Slf4jESLoggerFactory.getLogger("IndexSynchronizer");
}

